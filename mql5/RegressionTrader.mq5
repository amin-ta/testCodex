//-------------------------------------------------------------------
//|                                                RegressionTrader |
//|                        Generated by ChatGPT                     |
//|         Basic example of a regression-based trading robot       |
//-------------------------------------------------------------------
#property copyright "Generated by ChatGPT"
#property version   "1.00"
#property strict

// Input parameters
input string TimeframeList = "M5,M15,M30";   // Comma-separated list of timeframes
input int    RegressionDegree = 1;            // Degree of polynomial regression
input int    BarsToAnalyze   = 50;            // Number of bars used in regression
input int    MAPeriod        = 14;            // Moving Average period for filter
input double Threshold       = 0.0;           // Price difference threshold for signals

// Global variables
int          tf_array[];

//-------------------------------------------------------------------
//| Expert initialization function                                   |
//-------------------------------------------------------------------
int OnInit()
  {
   // Parse the timeframe list
   int count = StringSplit(TimeframeList, ',', tf_array);
   if(count <= 0)
     {
      Print("Incorrect timeframes specified.");
      return(INIT_FAILED);
     }
   Print("Initialized RegressionTrader with ", count, " timeframes.");
   return(INIT_SUCCEEDED);
  }

//-------------------------------------------------------------------
//| Main tick function                                               |
//-------------------------------------------------------------------
void OnTick()
  {
   double prediction = 0.0;
   int    tf_count   = ArraySize(tf_array);
   if(tf_count == 0) return;

   for(int i=0; i<tf_count; i++)
     {
      ENUM_TIMEFRAMES tf = (ENUM_TIMEFRAMES)PeriodSeconds(tf_array[i]);
      double value = PredictNext(tf);
      if(value != 0.0)
         prediction += value;
     }
   prediction /= tf_count;

   double ma = iMA(NULL, PERIOD_CURRENT, MAPeriod, 0, MODE_SMA, PRICE_CLOSE, 0);
   double price = (Bid + Ask) / 2.0;

   if(prediction > price + Threshold && price > ma)
      OpenPosition(ORDER_TYPE_BUY);
   else if(prediction < price - Threshold && price < ma)
      OpenPosition(ORDER_TYPE_SELL);
  }

//-------------------------------------------------------------------
//| Predict next price for given timeframe                            |
//-------------------------------------------------------------------
double PredictNext(ENUM_TIMEFRAMES tf)
  {
   int bars = Bars(tf);
   if(bars < BarsToAnalyze + 1) return(0.0);

   double data[];
   ArraySetAsSeries(data, true);
   CopyClose(NULL, tf, 0, BarsToAnalyze, data);

   double x[];
   ArrayResize(x, BarsToAnalyze);
   for(int i=0; i<BarsToAnalyze; i++)
      x[i] = i;

   double coeffs[];
   if(!PolynomialRegression(x, data, BarsToAnalyze, RegressionDegree, coeffs))
      return(0.0);

   double nextX = BarsToAnalyze;
   double pred  = 0.0;
   for(int d=0; d<=RegressionDegree; d++)
      pred += coeffs[d] * MathPow(nextX, d);

   return(pred);
  }

//-------------------------------------------------------------------
//| Polynomial regression using least squares                         |
//-------------------------------------------------------------------
bool PolynomialRegression(const double &x[], const double &y[], int n, int degree, double &coeffs[])
  {
   if(degree < 1 || degree >= n) return(false);
   ArrayResize(coeffs, degree + 1);

   double matrix[][];
   ArrayResize(matrix, degree+1);
   for(int i=0;i<=degree;i++)
     {
      ArrayResize(matrix[i], degree+2);
     }

   for(int row=0; row<=degree; row++)
     {
      for(int col=0; col<=degree; col++)
        {
         double sum = 0.0;
         for(int k=0; k<n; k++)
            sum += MathPow(x[k], row+col);
         matrix[row][col] = sum;
        }
      double sumY = 0.0;
      for(int k=0; k<n; k++)
         sumY += y[k] * MathPow(x[k], row);
      matrix[row][degree+1] = sumY;
     }

   // Gaussian elimination
   for(int i=0; i<=degree; i++)
     {
      double pivot = matrix[i][i];
      if(pivot == 0.0) return(false);
      for(int j=i; j<=degree+1; j++)
         matrix[i][j] /= pivot;
      for(int k=0; k<=degree; k++)
        {
         if(k==i) continue;
         double factor = matrix[k][i];
         for(int j=i; j<=degree+1; j++)
            matrix[k][j] -= factor * matrix[i][j];
        }
     }

   for(int i=0; i<=degree; i++)
      coeffs[i] = matrix[i][degree+1];

   return(true);
  }

//-------------------------------------------------------------------
//| Open position helper                                             |
//-------------------------------------------------------------------
void OpenPosition(ENUM_ORDER_TYPE type)
  {
   if(PositionSelect(Symbol())) return; // Already have a position
   MqlTradeRequest request;
   MqlTradeResult  result;
   ZeroMemory(request);
   request.action = TRADE_ACTION_DEAL;
   request.symbol = Symbol();
   request.type   = type;
   request.volume = 0.1; // default lot size
   request.price  = (type == ORDER_TYPE_BUY) ? Ask : Bid;
   request.deviation = 10;
   OrderSend(request, result);
   if(result.retcode != TRADE_RETCODE_DONE)
      Print("Order failed: ", result.retcode);
  }
//-------------------------------------------------------------------
